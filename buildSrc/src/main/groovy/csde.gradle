// Note, IntelliJ does not recognise the imported Java Classes, hence they are
// highlighted in Red. However, they are recognised in the gradle compilation.


// todo: Move more of the control flow over to JAVA. Sequence the steps in JAVA rather than Gradle
// todo: look at the declaration of the script variables, can they be combined with the declaration of the Project Context

// todo: investigate adding corda-cli to the class path then executing it directly - might not work as
//  gradle has to set up the jar file, so its not their when you start.

// Todo: write a test flow runner helper function
// todo: Write a final output message for deployCordapp which lists the set up VNodes
// todo: rename deployCPIsHelper
// todo: sort out the fully qualified class names in functions
// todo: add proper logging, rather than reading Stdout
// todo: add test corda running/live task
// todo: add a test to check docker is running and display error if not + halt start corda

import com.r3.csde.TestJavaClass
import com.r3.csde.CordaLifeCycleHelper
import com.r3.csde.ProjectContext
import com.r3.csde.DeployCPIsHelper
import com.r3.csde.BuildCPIsHelper
import com.r3.csde.ProjectUtils
import com.r3.csde.CordaStatusQueries
import com.r3.csde.CreateAndRegisterVNodesHelper

plugins {
    id 'java-library'
    id 'groovy'
    id 'java'
}


configurations {
    combinedWorker{
        canBeConsumed = false
        canBeResolved= true
    }

    myPostgresJDBC {
        canBeConsumed = false
        canBeResolved = true
    }

    notaryServerCPB {
        canBeConsumed = false
        canBeResolved = true
    }
}

// Dependencies for supporting tools
dependencies {
    combinedWorker "net.corda:corda-combined-worker:$combinedWorkerVersion"
    myPostgresJDBC 'org.postgresql:postgresql:42.4.1'
    notaryServerCPB("com.r3.corda.notary.plugin.nonvalidating:notary-plugin-non-validating-server:$cordaNotaryPluginsVersion") {
        artifact {
            classifier = 'package'
            extension = 'cpb'
        }
    }

    implementation "org.codehaus.groovy:groovy-json:3.0.9"
}


def pluginGroupName = "CSDE"
def pluginImplGroupName = "other"
def cordaBinDir = System.getenv("CSDE_CORDA_BIN") ?: System.getProperty('user.home') + "/.corda/corda5"
def cordaCliBinDir =  System.getenv("CSDE_CORDA_CLI") ?:System.getProperty('user.home') + "/.corda/cli"
def cordaJDBCDir = cordaBinDir + "/jdbcDrivers"
def cordaNotaryServerDir = cordaBinDir + "/notaryserver"
def signingCertAlias="gradle-plugin-default-key"
// Get error if this is not a autotyped object
// def signingCertFName = "$rootDir/config/gradle-plugin-default-key.pem"
def signingCertFName = rootDir.toString() + "/config/gradle-plugin-default-key.pem"
def keystoreAlias = "my-signing-key"
def keystoreFName = devEnvWorkspace + "/signingkeys.pfx"
def keystoreCertFName = devEnvWorkspace + "/signingkey1.pem"
def combiWorkerPidCacheFile = devEnvWorkspace + "/CordaPID.dat"
// todo: can we rely on the build directory always being /workflow/build? aslo, is the
//  workflow directory the correct place to build the cpb to. shoudl it be the main build directory.
def workflowBuildDir = rootDir.toString() + "/workflows/build"


// Need to read things from cordapp plugin
def appCpiName =  'cpi name'
def notaryCpiName =  'CSDE Notary Server CPI'


// todo: there should be a better way to set up these project context variables.
def projectContext = new ProjectContext(project,
        cordaClusterURL.toString(),
        cordaRpcUser,
        cordaRpcPasswd,
        devEnvWorkspace,
        // todo: why is this not obtained in the groovy def's abouve - its inconsistent.
        new String("${System.getProperty("java.home")}/bin"),
        dbContainerName,
        cordaJDBCDir,
        combiWorkerPidCacheFile,
        signingCertAlias,
        signingCertFName,
        keystoreAlias,
        keystoreFName,
        keystoreCertFName,
        appCpiName,
        notaryCpiName,
        devEnvWorkspace,
        cordaCliBinDir,
        cordaNotaryServerDir,
        workflowBuildDir,
        cordaNotaryPluginsVersion
)

def utils = new ProjectUtils()

def testJavaClass = new TestJavaClass()


// Initiate workspace folder

tasks.register('projInit') {
    group = pluginImplGroupName
    doLast {
        mkdir devEnvWorkspace
    }
}


// CordaLifeCycle tasks

def cordaLifeCycle = new CordaLifeCycleHelper(projectContext)

tasks.register("startCorda") {
    group = pluginGroupName
    dependsOn('getDevCordaLite', 'getPostgresJDBC')
    doLast {
        mkdir devEnvWorkspace
        cordaLifeCycle.startCorda()
    }
}

tasks.register("stopCorda") {
    group = pluginGroupName
    doLast {
        cordaLifeCycle.stopCorda()
    }
}

tasks.register("getPostgresJDBC") {
    group = pluginImplGroupName
    doLast {
        copy {
            from configurations.myPostgresJDBC
            into "$cordaJDBCDir"
        }
    }
}

tasks.register("getDevCordaLite", Copy) {
    group = pluginImplGroupName
    from configurations.combinedWorker
    into cordaBinDir
}


// Corda status queries

def cordaStatusQueries = new CordaStatusQueries(projectContext)


tasks.register('listVNodes') {
    group = pluginGroupName
    doLast {
        cordaStatusQueries.listVNodes()
    }
}

tasks.register('listCPIs') {
    group = pluginImplGroupName
    doLast {
        cordaStatusQueries.listCPIs()
    }
}

// Build CPI tasks

def buildCPIsHelper = new BuildCPIsHelper(projectContext)

tasks.register("testJava") {
    group = pluginGroupName
    doLast {
        buildCPIsHelper.buildCPIs()
    }
}

tasks.register("createGroupPolicy") {
    group = pluginImplGroupName
    dependsOn('projInit')
    doLast {
        buildCPIsHelper.createGroupPolicy()
    }
}

tasks.register("getNotaryServerCPB", Copy) {
    group = pluginImplGroupName
    from configurations.notaryServerCPB
    into cordaNotaryServerDir
}

tasks.register('createKeystore') {
    group = pluginImplGroupName
    dependsOn('projInit')
    doLast {
        buildCPIsHelper.createKeyStore()
    }
}

tasks.register('buildCPIs') {
    group = pluginGroupName
    // todo: do we benefit from using depends on here, there's isn't the option to skip if already done

    def dependsOnTasks = subprojects.collect {it.tasks.findByName("build") }
    dependsOnTasks.add('createGroupPolicy')
    dependsOnTasks.add('createKeystore')
    dependsOnTasks.add('getNotaryServerCPB')
    println("dependsOnTasks=${dependsOnTasks}")

    dependsOn dependsOnTasks

    doLast{
        buildCPIsHelper.buildCPIs()
    }
}


// deploy CPI tasks

def deployCPIsHelper = new DeployCPIsHelper(projectContext)

tasks.register("deployCPIs") {
    group = pluginImplGroupName
    dependsOn('buildCPIs')
    doLast {
        deployCPIsHelper.deployCPIs()
    }
}

// create and register Vnodes Tasks

def createAndRegisterVNodesHelper = new CreateAndRegisterVNodesHelper(projectContext)

tasks.register("createAndRegVNodes") {
    group = pluginImplGroupName
    dependsOn('deployCPIs')
    doLast {
        createAndRegisterVNodesHelper.createAndRegVNodes()
    }
}

// Empty task, just acts as the Task user entry point task.
tasks.register('deployCordapp') {
    group = pluginGroupName
    dependsOn("createAndRegVNodes")
}



